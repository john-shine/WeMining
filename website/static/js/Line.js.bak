LineClusterer.prototype = new google.maps.OverlayView();
LineClusterer.prototype.onAdd = function() { };
LineClusterer.prototype.onRemove = function() { };
LineClusterer.prototype.draw = function() {};
LineClusterer.prototype.idle = function(){};

function LineClusterer(map,line_data){
	this.map_ = map;
	this.lines_ = [];
	for(var x = 0;x < line_data.length;x = x + 1){
	    this.lines_.push({release_province_latlng: line_data[x].release_province_latlng,
						  forward_province_latlng: line_data[x].forward_province_latlng,
						  repostnum_: line_data[x].repost_num,
						  rank_: line_data[x].rank,
						  startLatLng_ : '',
						  endLatLng_ : '',
						  polyline_ : '',
						 // arrows_ : ''
						});
	}
	this.step_sum = 10;
	this.timeout = 200;
		
	for(var x = 0; x < this.lines_.length; x = x + 1){
		this.lines_[x].startLatLng_ = new google.maps.LatLng(this.lines_[x].release_province_latlng.split(' ')[0],this.lines_[x].release_province_latlng.split(' ')[1]);
		this.lines_[x].endLatLng_ = new google.maps.LatLng(this.lines_[x].forward_province_latlng.split(' ')[0],this.lines_[x].forward_province_latlng.split(' ')[1]);
		
		this.lines_[x].path = [];
		
		//var target_total_distance_ = google.maps.geometry.spherical.computeDistanceBetween(this.lines_[x].startLatLng_,this.lines_[x].endLatLng_);
		
		//var target_direction = google.maps.geometry.spherical.computeHeading(this.lines_[x].startLatLng_,this.lines_[x].endLatLng_);
		
		var step_lat = (this.lines_[x].endLatLng_.lat() - this.lines_[x].startLatLng_.lat()) / this.step_sum;
		var step_lng = (this.lines_[x].endLatLng_.lng() - this.lines_[x].startLatLng_.lng()) / this.step_sum;
		
		//var each_step_dis = target_total_distance_/this.step_sum;
		//var dis = each_step_dis;
		
		for(var y = 0;y < this.step_sum;y = y + 1){
			//this.lines_[x].path.push([this.lines_[x].startLatLng_,google.maps.geometry.spherical.computeOffset(this.lines_[x].startLatLng_,dis,target_direction)]);
			this.lines_[x].path.push([this.lines_[x].startLatLng_,new google.maps.LatLng(this.lines_[x].startLatLng_.lat()+step_lat*(y+1), this.lines_[x].startLatLng_.lng()+step_lng*(y+1))]);
			//dis = dis + each_step_dis;
		}
		this.lines_[x].path.push([this.lines_[x].startLatLng_,this.lines_[x].endLatLng_]);
		
		//console.log(this.lines_[x].path[0]);
		//console.log(this.lines_[x].repostnum);
		
	}
	
		var line_ = [];
		//var arrows_ = [];
		var x = 0;
		var that = this;
		(function(){
			if(line_ != []){
				for(var y = 0;y < line_.length;y = y + 1){
					line_[y].setMap(null);
					//arrows_[y].setMap(null);
				}
				line_ = [];
			}
			for(var y = 0;y < that.lines_.length;y = y + 1){
				var linecolor;
				var lineweight;
				lineweight = Math.ceil(that.lines_[y].repostnum_ / 2);
				switch(that.lines_[y].rank_){
					case 1:linecolor = '5F9F9F';break;//²ØÇà
					case 2:linecolor = 'D98719';break;//ÁÁÍ­
					case 3:linecolor = 'FF7F00';break;//Éºº÷É«
				}
				that.lines_[y].polyline_ = new google.maps.Polyline({  
					map: that.map_,
					strokeColor: linecolor,
					strokeOpacity: 1,
					strokeWeight: lineweight,
					path: that.lines_[y].path[x]
			   });
				//var points =[that.lines_[x].startLatLng_,that.lines_[x].endLatLng_];
				//that.lines_[y].arrows_ = new midArrows(points);
				line_.push(that.lines_[y].polyline_);
				//arrows_.push(that.lines_[y].arrows_);
			}
			x++;
			if(x < that.step_sum) setTimeout(arguments.callee, that.timeout);
		})();
//		for(var x = 0;x < this.step_sum;x = x + 1){
	//	}
		//var that = this;
		//function f(){console.log('pause for ' + that.timeout);}
}

LineClusterer.prototype.clearlines = function(){
	for(var x = 0;x < this.lines_.length; x = x + 1){
	   this.lines_[x].polyline_.setMap(null);
	   //this.lines_[x].arrows_.setMap(null);
	}
}
LineClusterer.prototype.getlines = function(){
	var lines = [];
	for(var x = 0;x < this.lines_.length; x = x + 1){
	   lines.push(this.lines_[x].polyline_);
	}
}
midArrows.prototype = new google.maps.OverlayView();
midArrows.prototype.onAdd = function() { };
midArrows.prototype.onRemove = function() { };
midArrows.prototype.draw = function() {};
midArrows.prototype.idle = function(){};
function midArrows(points)
        {
            if(points.length < 2) return;

            for (var i=1; i < points.length; i++)
            { 
                var p1=points[i-1];
                var p2=points[i];
                var dir = bearing(p1,p2);
                var dir = Math.round(dir/3) * 3;
                while (dir >= 120) {dir -= 120;}
                arrowIcon = new google.maps.MarkerImage('http://www.google.com/intl/en_ALL/mapfiles/dir_'+dir+'.png',      
     new google.maps.Size(24, 24),      
     new google.maps.Point(0,0),      
     new google.maps.Point(12, 12)
     ); 
     var marker = new google.maps.Marker({ 
        position: points[i],       
      map: map,         
      icon: arrowIcon,         
      }); 
        }
   }

        var degreesPerRadian = 180.0 / Math.PI;
        function bearing( from, to )
        {
            var lat1 = from.lat() * Math.PI / 180;
            var lon1 = from.lng() * Math.PI / 180;
            var lat2 = to.lat() * Math.PI / 180;
            var lon2 = to.lng() * Math.PI / 180;

            var angle = - Math.atan2( Math.sin( lon1 - lon2 ) * Math.cos( lat2 ), Math.cos( lat1 ) * Math.sin( lat2 ) - Math.sin( lat1 ) * Math.cos( lat2 ) * Math.cos( lon1 - lon2 ) );
            if ( angle < 0.0 )
                angle += Math.PI * 2.0;
            angle = angle * degreesPerRadian;
            angle = angle.toFixed(1);
            return angle;
        }
/*
LineClusterer.prototype.drawSlow = function (){
	console.log(this.num);
	if(this.num < this.step_sum){    
		  this.polyline_.setPath([]);
		  var end = google.maps.geometry.spherical.interpolate(this.startLatLng_,this.endLatLng_,this.dis);
		  this.polyline_.setPath([this.startLatLng_,end]);
		  this.dis = this.dis + this.each_step_dis;
		  console.log('start' + this.num);
	}
	if(this.num >= step_sum){
		  this.polyline_.setPath([]);
		  this.polyline_.setPath([this.startLatLng_,this.endLatLng_]);
		  this.polyline_.setMap(null);
		  console.log('end' + this.num);
		  clearInterval(this.drawslowInterval);
	 }
	this.num = this.num + 1;
}




/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
LineClusterer.prototype.extend = function(obj1, obj2) {
  return (function(object) {
    for (property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};

// Export Symbols for Closure
// If you are not going to compile with closure then you can remove the
// code below.
window['LineClusterer'] = LineClusterer;
LineClusterer.prototype['extend'] = LineClusterer.prototype.extend;
LineClusterer.prototype['onAdd'] = LineClusterer.prototype.onAdd;
LineClusterer.prototype['onRemove'] = LineClusterer.prototype.onRemove;
LineClusterer.prototype['idle'] = LineClusterer.prototype.idle;
LineClusterer.prototype['draw'] = LineClusterer.prototype.draw;

LineClusterer.prototype['clearline'] = LineClusterer.prototype.clearline;

